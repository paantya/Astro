I.Тема занятия: Алгоритмы сжатия. Статистические и
  словарные методы


В данной теме необходимо вспомнить методы сжатия, обратив особое
внимание на статические методы сжатия и сделать следующее задание:
написать функцию раскодировки данных по имеющемуся дереву (см. ниже).

Сжатие информации есть форма кодирования и служит двум основным
целям:

1. Сокращению объема пространства для хранения данных.
2. Сокращению количества времени при передачи информации.

Сжатие информации может быть обратимым и необратимым. Необратимое
сжатие используется, где допустима потеря качества воспроизведения --
человеческая речь, рисунки и т.д. Обратимое сжатие важно там, где
ошибки недопустимы (например тексты).

В астрономии естественно более важно обратимое сжатие, т.к. информация
несущественная сегодня, может оказаться важной для исследования
в последующем.

При сжатии информации основное внимание уделяется трем моментам:

1. Скорость работы
2. Степень сжатия
3. Объем памяти, занимаемой программы

Шеннон показал, что кодирование i-го символа оптимально прозводить
при помощи log_2(pi) битов, где pi -- вероятность появления
i-го символа в сообщении. Так как все символы в компьютере по техническим
причинам кодируются фиксируемым числом -- 8 бит (1~байт), то естественно 
существует резерв для сжатия информации.

Одним из самых распространенных методов сжатия долго оставался алгоритм
Хаффмана. Однако, в конце 70-х годов появились два других алгоритма
дающих лучшие результаты: метод арифметического кодирования и
метод Зива-Лемпела.

Алгоритмы сжатия можно разделить по методам проведения сжатия:

1. статистические
2. словарные 

Статистические методы сжатия основаны на том, что каждому
символу присваивается код, основанный на вероятности его
появление в тексте.

Словарные методы -- методы, в которых группа последовательных
символов заменяется кодом, а соответсвующая фраза хранится в
словаре.

В теории доказана, что словарные методы могут быть преобразованы
в статистические и найден алгоритм перевода словарного метода
в статистический.

При сжатии информации задача делится на две части:

1. кодировщик (декодировщик), кодирующий (раскодирующий) информацию 
на основе заданных правил (модели);

2. моделировщик, ищущий и задающий правила кодирования (модель) для
кодировщика (Например определяющий вероятность появления символа
в сообщении).


МОДЕЛИРОВАНИЕ

Задача моделирования это нахождения вероятности появления каждого
символов в тексте, для передачи найденной вероятности кодировщику.

При моделировании часто находят вероятности не только для отдельных 
символов, но и для контекстов (нескольких подряд идущих символов) 
текстов, которые затем и кодируются. Нетривиальная модель может содержать
тысячи контекстов с их вероятнотью.

Кодировщик и декодировщик должны использовать одну и ту же
модель. 

Моделирование взависимости от метода достижения данной
цели делится на три способа: статичное, полуадаптированное 
и адаптированное.

При статичном моделирование модель для текстов заранее определена
и хранится как кодировщиком так и декодировщиком. Недостатком
такого моделирования является плохое сжатие информации, когда
информация не соответствует выбранной модели. Достоинством
является быстрота и простота реализации.

Полуадаптированное моделирование строит для каждого текста свою модель,
на основании просмотра выбранного текста и данная модель записывается
вместе с текстом для декодировщика. В общем случае, передача модели
окупается за счет лучшего сжатия текстов.

Адаптированное (или динамическое) моделирование основанно на том,
что модель как кодировщиком, так и декодировщиком строится динамически
по одному и тому же алгоритму. Первоначально модель пустая, затем, с
приходом символов кодировщик и декодировщик одинаковым образом изменяют
модель.

Адаптированные модели не требуют предварительного просмотра текста и
сжимают текст достаточно хорошо.

КОДИРОВАНИЕ

Как указывалось выше, кодирование символа с вероятностью p желательно 
производить -- log_2(p) битами. Задача кодировщика, на основе вероятностей
полученных при моделировании выполнить кодирование символов. Классическим
методом кодирования является алгоритм Хаффмана. Алгоритм Хаффмана строит
для каждого символа код (последовательность нулей и единиц), который 
не является префиксом (началом) другого кода. Данный алгоритм относится 
к жадным алгоритмам и построенный им код называется кодом Хаффмена. 
Разберем его на примере. Пусть передается следующая информация:

абракадабра

Частота букв в этом слове следующая:

      "а" 5 
      "б" 2 
      "р" 2
      "д" 1
      "к" 1 

Алгоритм строит дерево, которое соответствует оптимальному коду.
Листьями дерева являются символами. Остальные узлы получаются
слиянием узлов имеющим меньшую частоту (вероятность).
В данном примере, вначале будет произведено слияние узлов (листьев)
"д" и "к" и получен узел "дк", затем "р" и "б" и получен узел
"рб" и потом "рб" и "дк" и получен "рбдк" и наконец корень~---
"абрдк".

                "абрдк"
                  11 
               /     \
             0/       \1              
           "а"      "брдк                   
            5      /   6  \                   
                 0/        \1                         
                "бр"      "дк"                    
                  4         2                      
               0/  \1    0/  \1                    
              "б"  "р" "д"   "к"                   
               2    2   1     1                    



После построения получаются следующие коды Хоффмана для
символов:

    "а"   0
    "б" 100
    "р" 101
    "д" 110
    "к" 111 


Таким образом:

абракадабра <--> 0 100 101 0 111 0 110 0 100 101  0
                 а  б   р  а  к  а  д  а  б   р   а


Итого нам потребуется 23 бита, вместо 88 (11*8).

Алгоритм Хаффмана используется в полуадаптированных моделях при статическом
кодированием.


II. Прилагаемые программы реализуют алгоритм Хаффман.

1. ModHaf.c - строит модель для кодировщика (раскодировщика). Модель
записывается в файл ModHaf.txt и содержит:

а) Информация о частоте группы символов (для листьев - символа).

б) В листьях десятичный код символа, а в узлах - 1.

в) Путь до данного узла от корня в виде 0 и 1 (0 - налево, 1 - направо).

2. HafCode.c - кодирует (раскодирует) информацию, по созданной
модели - ModHaf.txt

HafCode.c имеет входные параметры:

а) Ключ: a - кодировка
         e - раскодировка

б) Входной файл

в) Выходной файл 

В программе HafCode.c необходимо реализовать функцию
раскодирования (получения) очередного символа:

char GetChTree(int intIN, struct TreeCode *Root)

Функция имеет два аргумента:

int intIN - номер файла, в котором закодирована информация.

struct TreeCode *Root - указатель на дерево раскодировки, построенное 
из модели ModHaf.txt.

В кодированном файле каждый i-й символ закодирован log_2(pi) битами,
поэтому чтения 1-байта, приведет к чтению более одного символа.
Для получения значения очередного бита необходимо обратиться
к функции: GetCode(intIN), которая выдаст 0 или 1, т.е. идти
по левому или по правому дереву, или -1 - достигнут конец файла. 

Функция GetChTree(int intIN, struct TreeCode *Root), должна возратить
символ.


{
  char chSymb;
  int intPath=0;
  ..............
 return chSymb;
}
